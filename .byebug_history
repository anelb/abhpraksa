c
Time.parse(time_attempt)
time_attempt + 15 * 60
time_attempt
c
time_attempt + 15 * 60
time_attempt.class
time_attempt
c
attempt
c
session[:attempt]
attempt
session[:attempt]
c
time_attempt
session[:attempt]
c
time_attempt
session[:attempt]
c
time_attempt
session[:attempt]
c
time_attempt
session[:attempt]
attempt
session[:attempt]
c
session
c
session[:attempt]
c
session[:attempt]
c
session[:time_attempt]
c
session[:time]
session[:attempt]
session[:time]
c
session[:attempt]
session[attempt]
c
session[:attempt]
session[:time]
c
session[:time]
session[:attempt]
c
session[:attempt]
c
attempt
set_attempt
c
set_attempt
attempt
c
@attempt
attempt
c
attempt
c
attempt
c
@color
@size
c
@product_variants.map { |v| vc}
@product_variants.
@product_variants.map { ||}
@product_variants.uniq
@product_variants.color
@product_variants.size.uniq
@product_variants.size
@product_variants.count
@product_variants[0]
@product_variants
c
@product_variants.count
@product_variants
c
@product.product_variants.map { |x| x.size.product_size }.uniq
@product.product_variants.map { |x| x.size.product_size }
@product.product_variants[0].size.product_size
@product.product_variants[0].size
@product.product_variants
@product
@size
continue
c
continue
c
cc
c
cc
c
variant.methods.sort
variant.product_variant
variant.count
variant.class
variant
c
self.product_variants
self.product_variants.create(product_params)
self.categories
self
c
@product.errors.any?
@product.errors
c
@product.methods.sort
@product.save
@product.categories
@product
c
quantity.to_i.times { self.save! }
self.errors.any?
self.errors
c
@product.save
@product.categories
@product
c
@product.create_with_product_variants(params[:quanc
@product.create_with_product_variants(params[:quantity], product_params).errors
@product.create_with_product_variants(params[:quantity], product_params)
@product.categories
@product
c
Product.create(product_params).errors.full_messages
Product.create(product_params).errors.any?
Product.create(product_params)
product_params
quantity.to_i.class
quantity.to_i
quantity
quntity
c
params[:quantity].each { puts 1 }
params[:quantity].each do
params[:quantity]
params[:qunatity]
params
@product.create_with_category(params)
@product
c
@product.categories
@product
c
@product.categories.methods.sort
c
@product.errors.any?
@product.errors.any
@product
c
@product.errors.any?
@product.errors
@product
c
params
c
params[:category_id][0]
params[:category_id]
c
params
c
params
c
params
product_params
c
product_params
c
product_params
c
product_params
@product
c
@product.categories
@product
c
product_params
@product
c
params[:product][:brand_attributes][:id].to_i
params[:product][:brand_attributes][:id].class
params[:product][:brand_attributes][:id]
params[:product][:brand_attributes]
params
product_params
@product
c
params
c
params[:product][:brand_attributes][:id]
params[:product][:brand_attributes]
params[:brand_attributes]
params
params[:brand_attributes]
product_params
@product
c
@product.brand.methods.sort
@product.brand.methods
@product.methods.sort
c
e.message
e.instance_of?
e.inastance_of?
e.methods.sort
e.humanize
e
c
ActiveRecord::RecordNotFound
ActiveRecord::RecordNotFound:
e
Exception.class
Exception
c
@product
Exception
e.to_s
e
c
categories.first.title.mb_chars.downcase.split.first.capitalize.to_s
categories.first.title.mb_chars.downcase.split.first.capitalize
categories.first.title.mb_chars.downcase.split.first.to_s.capitalize
categories.first.title.mb_chars.downcase.split.first.to_s
categories.first.title.mb_chars.downcase.split.first
categories.first.title.mb_chars.downcase.split
c
categories.first.title.mb_chars.downcase.split
c
categories.first.title.mb_chars.downcase.split
c
categories.first.title.mb_chars.downcase.split
c
categories.first.title.mb_chars.downcase.split
c
categories.first.title.mb_chars.downcase.split
c
product
c
product_params
product
c
product_params
c
params
product_params
c
product_params
c
product_params
@product
